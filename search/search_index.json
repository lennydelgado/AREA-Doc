{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Installation","text":"<p>To begin with, in order to use the project, you need to clone it using the following command:</p> <pre><code>git clone git@github.com:EpitechPromo2026/B-CPP-500-MAR-5-1-rtype-theo.liennard.git\n</code></pre> <p>Once you have obtained the project, navigate to it to install the dependencies and build the project.</p> <p>The installation of dependencies varies significantly depending on the operating system used.</p> <p>Before proceeding, you need to install conan, which is an open-source tool that facilitates the installation of external C/C++ libraries.</p> <p>To install it, visit https://conan.io/downloads</p> <p>Install conan according to your operating system or the method you prefer to use.</p> Automatic InstallationManual Installation For WindowsFor Linux and MacOS <p>To install the project you can use the following command at the root of the project:</p> <pre><code>./windowCompile.bat\n</code></pre> <p>Note</p> <p>if the build folder already exists, use the following command to rebuild the project:</p> <pre><code>./windowCompile.bat all\n</code></pre> <p>Warning</p> <p>You may encounter a conan error during the execution of this command. If this is the case, you must execute the following command:</p> <pre><code>conan config home\n</code></pre> <p>then add the following lines to the global.conf file in folder that was returned by the previous command:</p> <pre><code>tools.system.package_manager:mode=install\ntools.system.package_manager:sudo=True\n</code></pre> <p>Warning</p> <p>If you encounter other errors, try to do a manual installation.</p> <p>To install the project you can use the following command at the root of the project:</p> <pre><code>./unixCompile.sh\n</code></pre> <p>Note</p> <p>if the build folder already exists, use the following command to rebuild the project:</p> <pre><code>./unixCompile.sh all\n</code></pre> <p>Warning</p> <p>You may encounter a conan error during the execution of this command. If this is the case, you must execute the following command:</p> <pre><code>conan config home\n</code></pre> <p>then add the following lines to the global.conf file in folder that was returned by the previous command:</p> <pre><code>tools.system.package_manager:mode=install\ntools.system.package_manager:sudo=True\n</code></pre> <p>Warning</p> <p>If you encounter other errors, try to do a manual installation.</p>"},{"location":"#dependency-installation","title":"Dependency Installation","text":"<p>To verify its installation, you can now execute the following command, which allows conan to detect the version of the compiler you are using and several other necessary pieces of information for its operation.</p> <p>Note</p> <p>This command must be executed in the project directory, not elsewhere.</p> <pre><code>conan profile detect --force\n</code></pre> <p>Once this is done, you need to prepare the files to install the dependencies.</p> <pre><code>conan install . --output-folder=build --build=missing\n</code></pre> <p>Warning</p> <p>You may encounter an error during the execution of this command. If this is the case, you must execute the following command:</p> <pre><code>conan config home\n</code></pre> <p>then add the following lines to the global.conf file in folder that was returned by the previous command:</p> <pre><code>tools.system.package_manager:mode=install\ntools.system.package_manager:sudo=True\n</code></pre> For Linux and MacOSFor Linux and MacOS (alt)For WindowsFor Windows (alt) <p>To complete the installation of dependencies, execute the following commands. First, proceed to generate the project files.</p> <pre><code>cmake -S . -B ./build --preset conan-release\n</code></pre> <p>Then, you can initiate the project compilation with the following command:</p> <pre><code>cmake --build build\n</code></pre> <p>To complete the installation of dependencies, execute the following commands. First, navigate to the build directory.</p> <pre><code>cd build\n</code></pre> <p>Then, proceed to install the dependencies.</p> <pre><code>cmake .. -DCMAKE_TOOLCHAIN_FILE=conan_toolchain.cmake -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>Now, you can initiate the project compilation with the following command:</p> <p>Note</p> <p>To execute this command, you must be in the build directory.</p> <pre><code>cmake --build .\n</code></pre> <p>To complete the installation of dependencies, execute the following commands. First, proceed to generate the project files.</p> <pre><code>cmake -S . -B ./build --preset conan-default\n</code></pre> <p>Then, you can initiate the project compilation with the following command:</p> <pre><code>cmake --build build --config Release\n</code></pre> <p>To complete the installation of dependencies, execute the following commands. First, navigate to the build directory.</p> <pre><code>cd build\n</code></pre> <p>Then, proceed to install the dependencies.</p> <pre><code># assuming Visual Studio 15 2017 is your VS version and that it matches your default profile\ncmake .. -G \"Visual Studio 15 2017\" -DCMAKE_TOOLCHAIN_FILE=./conan_toolchain.cmake\n</code></pre> <p>Now, you can initiate the project compilation with the following command:</p> <p>Note</p> <p>To execute this command, you must be in the build directory.</p> <pre><code>cmake --build . --config Release\n</code></pre>"},{"location":"GameDesign/gameDesign/","title":"Getting started","text":""},{"location":"GameDesign/gameDesign/#wip","title":"WIP","text":"<p>IN WIP</p>"},{"location":"GameEngine/ecs/","title":"ECS (Entity Component System)","text":""},{"location":"GameEngine/ecs/#what-is-ecs","title":"What is ECS?","text":"<p>ECS is a design pattern that is used to make games. It is a way to organize your code in a way that makes it easier to add new features to your game. It is also a way to make your code more efficient.</p>"},{"location":"GameEngine/ecs/#methods","title":"Methods","text":""},{"location":"GameEngine/ecs/#component","title":"Component","text":"<p>A component is a piece of data that can be attached to an entity. A component can be anything from a position to a velocity to a sprite. A component can also be a group of components.</p>"},{"location":"GameEngine/ecs/#gameengineecsregistercomponent","title":"GameEngine::ecsRegisterComponent","text":"<pre><code>template &lt;typename Component&gt;\nvoid ecsRegisterComponent();\n</code></pre> <p>This function registers a component to the game engine. This means that the game engine will be able to use this component.</p>"},{"location":"GameEngine/ecs/#gameengineecsgetcomponents","title":"GameEngine::ecsGetComponents","text":"<pre><code>template &lt;typename Component&gt;\nSparseArray&lt;Component&gt; &amp;ecsGetComponents();\n</code></pre> <p>This function returns a reference to the component list of a certain type.</p>"},{"location":"GameEngine/ecs/#entity","title":"Entity","text":"<p>An entity is an object that has a unique ID and a list of components. An entity can be anything from a player to a bullet to a wall. An entity can also be a group of entities.</p>"},{"location":"GameEngine/ecs/#gameengineecsspawnentity","title":"GameEngine::ecsSpawnEntity","text":"<pre><code>Entity ecsSpawnEntity();\n</code></pre> <p>This function creates a new entity and returns its ID.</p>"},{"location":"GameEngine/ecs/#gameengineecsentityfromindex","title":"GameEngine::ecsEntityFromIndex","text":"<pre><code>Entity ecsEntityFromIndex(size_t index);\n</code></pre> <p>Since the constructor of the Entity class is private, you can't create an entity directly. Instead, you have to use this function to get an entity from its index.</p> <p>All entities are implicitly convertable to their index, so you can use this function to get an entity from its index.</p>"},{"location":"GameEngine/ecs/#gameengineecskillentity","title":"GameEngine::ecsKillEntity","text":"<pre><code>void ecsKillEntity(Entity entity);\n</code></pre> <p>This function kills an entity. This means that it will be removed from the game engine and all of its components will be removed from the game engine.</p>"},{"location":"GameEngine/ecs/#gameengineecskillallentities","title":"GameEngine::ecsKillAllEntities","text":"<pre><code>void ecsKillAllEntities();\n</code></pre> <p>This function kills all entities. This means that they will be removed from the game engine and all of their components will be removed from the game engine.</p> <p>Useful for when you want to restart the game or you when you leave a menu to go to the game and you want to remove all the entities from the menu.</p>"},{"location":"GameEngine/ecs/#gameengineecsaddcomponent","title":"GameEngine::ecsAddComponent","text":"<pre><code>template &lt;typename Component&gt;\ntypename SparseArray&lt;Component&gt;::reference_type ecsAddComponent(Entity entity, Component component);\n</code></pre> <p>This function adds a component to an entity. It returns a reference to the component that was added.</p>"},{"location":"GameEngine/ecs/#gameengineecsemplacecomponent","title":"GameEngine::ecsEmplaceComponent","text":"<pre><code>template &lt;typename Component, typename... Args&gt;\ntypename SparseArray&lt;Component&gt;::reference_type ecsEmplaceComponent(Entity entity, Args &amp;&amp;... args);\n</code></pre> <p>This function emplaces a component to an entity. It returns a reference to the component that was added.</p>"},{"location":"GameEngine/ecs/#gameengineecsremovecomponent","title":"GameEngine::ecsRemoveComponent","text":"<pre><code>template &lt;typename Component&gt;\nvoid ecsRemoveComponent(Entity entity);\n</code></pre> <p>This function removes a component from an entity.</p>"},{"location":"GameEngine/ecs/#system","title":"System","text":"<p>A system is a function that takes a list of components and does something with them. A system can be anything from a movement system to a rendering system to a collision system.</p>"},{"location":"GameEngine/ecs/#gameengineecsaddsystem","title":"GameEngine::ecsAddSystem","text":"<pre><code>template &lt;class... Components, typename Function&gt;\nstd::function&lt;void()&gt; ecsAddSystem(Function const &amp;f)\n\ntemplate &lt;class... Components, typename Function&gt;\nstd::function&lt;void()&gt; ecsAddSystem(Function &amp;&amp;f)\n</code></pre> <p>This function adds a system to the game engine. It returns a function that you can call to remove the system from the game engine.</p> <p>The function that you pass to this function must take a <code>GameEngine &amp;</code> as a parameter, a list of components you want to use and return void.</p> <pre><code>template &lt;class... Components, typename... ExtraParams, typename Function&gt;\nstd::function&lt;void()&gt; ecsAddSystem(Function &amp;&amp;f, ExtraParams &amp;&amp;...p)\n</code></pre> <p>This function adds a system to the game engine. It returns a function that you can call to remove the system from the game engine.</p> <p>The function that you pass to this function must take a <code>GameEngine &amp;</code> as a parameter, a list of components you want to use, some extra parameters if you need them and return void.</p>"},{"location":"GameEngine/ecs/#gameengineecsclearsystems","title":"GameEngine::ecsClearSystems","text":"<pre><code>void ecsClearSystems();\n</code></pre> <p>This function removes all systems from the game engine.</p>"},{"location":"GameEngine/ecs/#gameengineecsrunsystems","title":"GameEngine::ecsRunSystems","text":"<pre><code>void ecsRunSystems();\n</code></pre> <p>This function runs all systems added to the game engine in the order they were added.</p>"},{"location":"GameEngine/ecs/#gameengineecsrunsinglesystem","title":"GameEngine::ecsRunSingleSystem","text":"<pre><code>template &lt;class... Components, typename Function&gt;\nvoid ecsRunSingleSystem(Function &amp;&amp;f)\n</code></pre> <p>This function runs a system once. It takes a function that takes a <code>GameEngine &amp;</code> as a parameter, a list of components you want to use and returns void.</p> <pre><code>template &lt;class... Components, typename... ExtraParams, typename Function&gt;\nvoid ecsRunSingleSystem(Function &amp;&amp;f, ExtraParams &amp;&amp;...p)\n</code></pre> <p>This function runs a system once. It takes a function that takes a <code>GameEngine &amp;</code> as a parameter, a list of components you want to use, some extra parameters if you need them and returns void.</p>"},{"location":"GameEngine/gameEngine/","title":"Getting started","text":""},{"location":"GameEngine/gameEngine/#game-engine","title":"Game Engine","text":""},{"location":"GameEngine/gameEngine/#introduction","title":"Introduction","text":"<p>The Game Engine is the main part of the project, it is the part that manages the game loop, the entities, the systems, the events, the rendering and the network.</p>"},{"location":"GameEngine/gameEngine/#goal","title":"Goal","text":"<p>The goal of the game engine is to provide a simple and efficient way to create a game with the ECS architecture it provides and to be able to use it in a networked environment.</p>"},{"location":"GameEngine/gameEngine/#architectural-view","title":"Architectural View","text":"<pre><code>stateDiagram-v2\n    state Game {\n        direction LR\n        state GameLogic {\n            direction LR\n            player\n            ennemy\n            ...\n        }\n        state GameEngine {\n            direction LR\n            state Core {\n                state ECS {\n                    state Entity {\n                        direction LR\n                        [Components...]\n                    }\n                    Entity --&gt; System\n                }\n                state Network {\n                    direction LR\n                    ...\n                }\n                state Event {\n                    direction LR\n                    KeyboardEvent\n                    MouseEvent\n                    WindowEvent\n                }\n                state Render {\n                    direction LR\n                    state SFML {\n                        direction LR\n                        2D\n                    }\n                }\n                state SpatialAudio {\n                    direction LR\n                    state SFMLAudio {\n                        direction LR\n                        Audio2D\n                        Audio3D\n                    }\n                }\n            }\n            state Module {\n                state TimeManager {\n                    direction LR\n                    FunctionWithTimeOut\n                    FunctionOnTick\n                }\n                state LuaManager {\n                    direction LR\n                    LoadLuaScripts\n                    AddC++FunctionToLua\n                    RunLuaFunction\n                }\n                state JsonManager {\n                    direction LR\n                    LoadJsonFile\n                    GetInformationFromJson\n                }\n            }\n        }\n    }</code></pre>"},{"location":"GameEngine/gameEngine/#first-steps","title":"First steps","text":"<p>To use the game engine you need to have the following dependencies:</p> <ul> <li>Conan - Package Manager</li> <li>CMake - Compiler</li> </ul> <p>Follow the installation instructions on the Installation page and you should have the game engine compiled as a library in the <code>build/GameEngine</code> folder.</p>"},{"location":"GameEngine/gameEngine/#tutorial","title":"Tutorial","text":"<p>In this section we will explain how to use the game engine to create a simple game.</p>"},{"location":"GameEngine/gameEngine/#include-required-files","title":"Include required files","text":"<p>To use the game engine you need to include the following files:</p> <pre><code>#include \"gameEngine.hpp\"\n</code></pre>"},{"location":"GameEngine/gameEngine/#create-your-own-components","title":"Create your own components","text":"<p>The game engine is based on the ECS architecture, so you need to create your own components to use it or use the ones already created. For the sake of the example we will create our own components.</p> <p>To create a component you just need to create a struct with the properties you want to have in your component.</p> <pre><code>struct Position {\nfloat x;\nfloat y;\n};\n\nstruct Velocity {\nfloat x;\nfloat y;\n};\n\nstruct Sprite {\ngameEngine::Sprite sprite;\n\nSprite() {\nsprite.setTexture(gameEngine::Texture());\n}\n\nsetPosition(float x, float y) {\nsprite.setPosition(x, y);\n}\n};\n</code></pre>"},{"location":"GameEngine/gameEngine/#create-your-own-systems","title":"Create your own systems","text":"<p>The game engine is based on the ECS architecture, so you need to create your own systems to use it or use the ones already created. For the sake of the example we will create our own systems.</p> <p>To create a system you just need to create a function that takes a <code>GameEngine &amp;</code> as a parameter, a list of components you want to use, some extra parameters if you need them and return void.</p> <pre><code>void move(GameEngine &amp;engine, SparseArray&lt;Position&gt; &amp;positions, SparseArray&lt;Velocity&gt; &amp;velocities) {\nfor (auto &amp;pos : positions) {\nif (velocities.has(pos.first)) {\npos.second.x += velocities[pos.first].x;\npos.second.y += velocities[pos.first].y;\n}\n}\n}\n\nvoid render(GameEngine &amp;engine, SparseArray&lt;Position&gt; &amp;positions, SparseArray&lt;Sprite&gt; &amp;sprites, gameEngine::RenderWindow &amp;window) {\nfor (auto &amp;pos : positions) {\nif (sprites.has(pos.first)) {\nsprites[pos.first].setPosition(pos.second.x, pos.second.y);\nwindow.draw(sprites[pos.first].sprite);\n}\n}\n}\n</code></pre>"},{"location":"GameEngine/gameEngine/#create-your-own-game","title":"Create your own game","text":"<p>To create your own game you first need to register your components and systems to the game engine.</p> <pre><code>GameEngine engine;\ngameEngine::RenderWindow window(gameEngine::VideoMode(1280, 720), \"GameEngine window\");\n\nengine.ecsRegisterComponent&lt;Position&gt;();\nengine.ecsRegisterComponent&lt;Velocity&gt;();\n\nengine.ecsAddSystem&lt;Position, Velocity&gt;(move);\nengine.ecsAddSystem&lt;Position, Sprite&gt;(render, window);\n</code></pre> <p>Then you need to create your entities and add them to the game engine.</p> <pre><code>Entity entity = engine.ecsSpawnEntity();\n\nPosition pos{0, 0};\nengine.ecsAddComponent(entity, pos);\n\nVelocity vel{1, 1};\nengine.ecsAddComponent(entity, vel);\n</code></pre> <p>Now that we have setup our entity we can start the game loop.</p> <pre><code>while (window.isOpen()) {\ngameEngine::Event event;\nwhile (window.pollEvent(event)) {\nif (event.type == gameEngine::Event::Closed) {\nwindow.close();\n}\n}\n\nwindow.clear();\n\nengine.ecsRunSystems();\n\nwindow.display();\n}\n</code></pre> <p>But maybe you want to execute some code based on a tick rate, you can do that by using the <code>setInterval</code> method.</p> <pre><code>engine.timeSetInterval([]() {\nstd::cout &lt;&lt; \"Hello World every 1s\" &lt;&lt; std::endl;\n}, 1000); // 1000ms = 1s\n</code></pre> <p>Or maybe you want to execute some code only once but after a certain amount of time, you can do that by using the <code>setTimeout</code> method.</p> <pre><code>engine.timeSetTimeout([]() {\nstd::cout &lt;&lt; \"Hello World after 10s\" &lt;&lt; std::endl;\n}, 10000); // 10000ms = 10s\n</code></pre>"},{"location":"GameEngine/gameEngine/#full-example","title":"Full example","text":"<pre><code>#include \"gameEngine.hpp\"\n\nstruct Position {\nfloat x;\nfloat y;\n};\n\nstruct Velocity {\nfloat x;\nfloat y;\n};\n\nstruct Sprite {\ngameEngine::Sprite sprite;\n\nSprite() {\nsprite.setTexture(gameEngine::Texture());\n}\n\nsetPosition(float x, float y) {\nsprite.setPosition(x, y);\n}\n};\n\nvoid move(GameEngine &amp;engine, SparseArray&lt;Position&gt; &amp;positions, SparseArray&lt;Velocity&gt; &amp;velocities) {\nfor (auto &amp;pos : positions) {\nif (velocities.has(pos.first)) {\npos.second.x += velocities[pos.first].x;\npos.second.y += velocities[pos.first].y;\n}\n}\n}\n\nvoid render(GameEngine &amp;engine, SparseArray&lt;Position&gt; &amp;positions, SparseArray&lt;Sprite&gt; &amp;sprites, gameEngine::RenderWindow &amp;window) {\nfor (auto &amp;pos : positions) {\nif (sprites.has(pos.first)) {\nsprites[pos.first].setPosition(pos.second.x, pos.second.y);\nwindow.draw(sprites[pos.first].sprite);\n}\n}\n}\n\nint main() {\nGameEngine engine;\ngameEngine::RenderWindow window(gameEngine::VideoMode(1280, 720), \"GameEngine window\");\n\nengine.ecsRegisterComponent&lt;Position&gt;();\nengine.ecsRegisterComponent&lt;Velocity&gt;();\n\nengine.ecsAddSystem&lt;Position, Velocity&gt;(move);\nengine.ecsAddSystem&lt;Position, Sprite&gt;(render, window);\n\nEntity entity = engine.ecsSpawnEntity();\n\nPosition pos{0, 0};\nengine.ecsAddComponent(entity, pos);\n\nVelocity vel{1, 1};\nengine.ecsAddComponent(entity, vel);\n\nengine.timeSetInterval([]() {\nstd::cout &lt;&lt; \"Hello World every 1s\" &lt;&lt; std::endl;\n}, 1000); // 1000ms = 1s\nengine.timeStartTick();\n\nwhile (window.isOpen()) {\ngameEngine::Event event;\nwhile (window.pollEvent(event)) {\nif (event.type == gameEngine::Event::Closed) {\nwindow.close();\n}\n\nif (event.type == gameEngine::Event::KeyPressed) {\nif (event.key.code == gameEngine::Keyboard::Escape) {\nengine.timeSetTimeout([]() {\nstd::cout &lt;&lt; \"Hello World after 10s\" &lt;&lt; std::endl;\n}, 10000); // 10000ms = 10s\n}\n}\n}\n\nwindow.clear();\n\nengine.ecsRunSystems();\n\nwindow.display();\n}\n\nreturn 0;\n}\n</code></pre>"},{"location":"GameEngine/gameEngine/#methods","title":"Methods","text":"<p>To see all the methods available in the game engine, please refer to the corresponding documentation page depending on the module you want to use.</p> <ul> <li>ECS</li> <li>Network</li> <li>Time</li> <li>Lua</li> <li>Json</li> </ul> <p>Note</p> <p>If you know how to use the method but don't remember it's exact name, all maethod are named with the following convention: <code>module</code> + <code>MethodName</code> So for example if you want to use the <code>ecsSpawnEntity</code> method you know that it is in the <code>ecs</code> module, so you can just type <code>ecs</code> and the auto-completion will show you all the methods available in the <code>ecs</code> module.</p>"},{"location":"GameEngine/gameEngine/#authorscontacts","title":"Authors/Contacts","text":"<ul> <li>Kenan Blasius</li> </ul>"},{"location":"GameEngine/gameEngine/#conclusion","title":"Conclusion","text":"<p>The game engine is the main part of the project, it is the part that manages the entities, the systems, the events and the rendering.</p>"},{"location":"GameEngine/json/","title":"Json Manager","text":""},{"location":"GameEngine/json/#what-is-the-json-manager","title":"What is the Json Manager?","text":"<p>The Json Manager is a module of the Game Engine that allows you to load and use Json files in your game.</p>"},{"location":"GameEngine/json/#methods","title":"Methods","text":""},{"location":"GameEngine/json/#gameenginejsonloadfile","title":"GameEngine::jsonLoadFile","text":"<pre><code>void jsonLoadFile(const std::string &amp;path);\n</code></pre> <p>This function loads a Json file.</p>"},{"location":"GameEngine/json/#gameenginejsongetfile","title":"GameEngine::jsonGetFile","text":"<pre><code>nlohmann::json jsonGetFile(const std::string &amp;path);\n</code></pre> <p>This function returns the Json file loaded with <code>jsonLoadFile</code>.</p> <p>The parameter <code>path</code> is the path to the Json file you want to get.</p>"},{"location":"GameEngine/json/#gameenginejsongetvalue","title":"GameEngine::jsonGetValue","text":"<pre><code>template &lt;typename T, class... Args&gt;\nT jsonGetValue(const std::string &amp;path, Args... args)\n\ntemplate &lt;typename T, class... Args&gt;\nT jsonGetValue(nlohmann::json &amp;json, Args... args)\n</code></pre> <p>This function returns the value of a Json file.</p> <p>The parameter <code>path</code> is the path to the value you want to get.</p> <p>The parameters <code>args</code> are the keys to the value you want to get, it can be a string or an int.</p>"},{"location":"GameEngine/lua/","title":"Lua Manager","text":""},{"location":"GameEngine/lua/#what-is-the-lua-manager","title":"What is the Lua Manager?","text":"<p>The Lua Manager is a module of the Game Engine that allows you to use Lua scripts in your game.</p>"},{"location":"GameEngine/lua/#methods","title":"Methods","text":""},{"location":"GameEngine/lua/#gameenginelualoadfile","title":"GameEngine::luaLoadFile","text":"<pre><code>void luaLoadFile(const std::string &amp;path);\n</code></pre> <p>This function loads a Lua script from a file.</p>"},{"location":"GameEngine/lua/#gameengineluaaddcppfunction","title":"GameEngine::luaAddCppFunction","text":"<pre><code>void luaAddCppFunction(const std::string &amp;fromFile, const std::string &amp;name, lua_CFunction func);\n</code></pre> <p>This function add a C++ function to the Lua state of a script so you can call it from the script.</p> <p>The parameter <code>fromFile</code> is the path of the script you want to add the function to.</p> <p>The parameter <code>name</code> is the name of the function in the script.</p> <p>The function <code>func</code> must have the following signature:</p> <pre><code>int func(lua_State *L);\n</code></pre> <p>The int returned by the function is the number of values returned by the function.</p>"},{"location":"GameEngine/lua/#gameengineluacallfunction","title":"GameEngine::luaCallFunction","text":"<pre><code>template &lt;typename... Args&gt;\nvoid luaCallFunction(const std::string &amp;fromFile, const std::string &amp;name, int nbReturnValue, Args... args);\n</code></pre> <p>This function calls a function from a script.</p> <p>The parameter <code>fromFile</code> is the path of the script you want to call the function from.</p> <p>The parameter <code>name</code> is the name of the function in the script.</p> <p>The parameter <code>nbReturnValue</code> is the number of values returned by the function.</p> <p>The parameters <code>args</code> are the arguments passed to the function.</p>"},{"location":"GameEngine/lua/#gameengineluagetreturnvalue","title":"GameEngine::luaGetReturnValue","text":"<pre><code>template &lt;typename... Args&gt;\nvoid luaGetReturnValue(const std::string &amp;fromFile, Args&amp;... args);\n</code></pre> <p>This function gets the return values of the last function called.</p> <p>The parameter <code>fromFile</code> is the path of the script you want to get the return values from.</p> <p>The parameters <code>args</code> are the variables that will be set with the return values.</p>"},{"location":"GameEngine/lua/#gameengineluagetarguement","title":"GameEngine::luaGetArguement","text":"<pre><code>template &lt;typename... Args&gt;\nstatic void luaGetArguement(lua_State *L, Args&amp;... args);\n</code></pre> <p>This function gets the arguments passed to a function.</p> <p>It is used in the C++ functions added to the Lua state to get the arguments passed to the function in the script.</p> <p>The parameter <code>L</code> is the Lua state required in the function signature.</p> <p>The parameters <code>args</code> are the variables that will be set with the arguments.</p>"},{"location":"GameEngine/lua/#gameengineluasendresult","title":"GameEngine::luaSendResult","text":"<pre><code>template &lt;typename... Args&gt;\nstatic void luaSendResult(lua_State *luaState, Args&amp;... args)\n</code></pre> <p>This function sends the return values of a C++ function to the Lua state.</p> <p>It is used in the C++ functions added to the Lua state to send the return values of the function to the script.</p> <p>The parameter <code>luaState</code> is the Lua state required in the function signature.</p> <p>The parameters <code>args</code> are the variables that will be sent as return values.</p>"},{"location":"GameEngine/lua/#gameengineluaprintstack","title":"GameEngine::luaPrintStack","text":"<pre><code>void luaPrintStack(const std::string &amp;fromFile);\n</code></pre> <p>This function prints the Lua stack of a script.</p>"},{"location":"GameEngine/network/","title":"Network","text":""},{"location":"GameEngine/network/#introduction","title":"Introduction","text":"<p>The networking is a really important part of the project. It is used to communicate between the server and the client.</p> <p>For more information about the network, please refer to the network page</p>"},{"location":"GameEngine/time/","title":"Time Manager","text":""},{"location":"GameEngine/time/#what-is-the-time-manager","title":"What is the Time Manager?","text":"<p>The Time Manager is a module of the Game Engine that allows you to manage time in your game. It allows you to create timers and to execute functions on a regular basis.</p>"},{"location":"GameEngine/time/#methods","title":"Methods","text":""},{"location":"GameEngine/time/#gameenginetimesettimeout","title":"GameEngine::timeSetTimeout","text":"<pre><code>void timeSetTimeout(std::function&lt;void()&gt; f, time_t timeout);\n</code></pre> <p>This function executes the function <code>f</code> after <code>timeout</code> milliseconds.</p> <p>Hint: Use lambda functions to pass parameters to your function.</p>"},{"location":"GameEngine/time/#gameenginetimesetinterval","title":"GameEngine::timeSetInterval","text":"<pre><code>std::function&lt;void()&gt; timeSetInterval(std::function&lt;void()&gt; f, time_t tickTime);\n</code></pre> <p>This function executes the function <code>f</code> every <code>tickTime</code> milliseconds. It returns a function that you can call to remove the function from the time manager, stopping it from being executed.</p> <p>Hint: Use lambda functions to pass parameters to your function.</p>"},{"location":"GameEngine/time/#gameenginetimestarttick","title":"GameEngine::timeStartTick","text":"<pre><code>void timeStartTick();\n</code></pre> <p>This function starts the tick of the time manager. All intervals will start executing.</p>"},{"location":"GameEngine/time/#gameenginetimestoptick","title":"GameEngine::timeStopTick","text":"<pre><code>void timeStopTick();\n</code></pre> <p>This function stops the tick of the time manager. All intervals will stop executing.</p>"},{"location":"Network/network/","title":"Networking Library","text":""},{"location":"Network/network/#introduction","title":"Introduction","text":"<p>The networking is a really important part of the project. It is used to communicate between the server and the client.</p>"},{"location":"Network/network/#objectif","title":"Objectif","text":"<p>The stake of this part is to be able to send and receive any kind of data. It has to be fast and reliable.</p>"},{"location":"Network/network/#architectural-view","title":"Architectural View","text":"<pre><code>stateDiagram-v2\n    direction LR\n    state Network {\n        [*] --&gt; Server\n        [*] --&gt; Client\n        Server --&gt; tcpConnection\n        Server --&gt; udpConnection\n        Client --&gt; tcpConnection\n        Client --&gt; udpConnection\n        state Server {\n            direction LR\n            MultiplesTcpConnections\n            MultiplesUdpConnections\n            state update {\n                [*] --&gt; tcp\n                [*] --&gt; udp\n            }\n        }\n        state Client {\n            direction LR\n            UniqueTcpConnection\n            UniqueUdpConnection\n            state _update {\n                [*] --&gt; _tcp\n                [*] --&gt; _udp\n            }\n        }\n        tcpConnection --&gt; tsQueueMessages\n        udpConnection --&gt; tsQueueMessages\n    }</code></pre>"},{"location":"Network/network/#main-systems","title":"Main systems","text":"<p>The main system of the FLib is the Tcp protocol. However, the lib is providing a custom client wich uses tcp protocol to connect to clients and to validate them. Then when the game starts, it uses an udp custom protocol that sends and receive datas faster. Those two protocol works together, each one has his own strenght, and his weaknesses. Use the tcp to send important informations because the udp is less reliable and could lose the packet.</p>"},{"location":"Network/network/#usage","title":"Usage","text":"<p>the network interface is based on the asio library. it is working on all platforms and is fully customisable. To use the FLib, you have to create custom DataTypes. Those DataTypes will be used to identify the type of data that you want to send.</p> <p>You can add or modify those DataTypes in the file <code>protocol.hpp</code>.</p> <p>Here is an example:</p> <p><pre><code>    enum class CustomMsgTypes : uint32_t\n{\nPlayerData,\nFireBullet,\nMovePlayer,\nPlayerHealth\n};\n</code></pre> This is basicly an enum that you can use to implement different behaviors. Those DataTypes will be used in the Networking implementation. Go to Data Transfer for more details. Now all you have to do is to create a client and a server. Send datas using the <code>message</code> class and upon receive use the message class to extract the datas. For the server, you can use the methode <code>onMessage</code> to implement what you want to do when you receive a message.</p> <pre><code>    virtual void onMessage(std::shared_ptr&lt;connection&lt;T&gt;&gt;&amp; client, Message&lt;T&gt;&amp; msg)\n</code></pre>"},{"location":"Network/network/#here-is-a-simple-example-of-how-to-use-the-network-library","title":"Here is a simple example of how to use the network library.","text":""},{"location":"Network/network/#message-class","title":"message Class","text":"<p><pre><code>template &lt;typename T&gt;\nstruct MessageHeader\n{\nT id{}; // {} = default value / constructor for class\nsize_t size = 0;\n};\n\ntemplate &lt;typename T&gt;\nstruct message\n{\nMessageHeader&lt;T&gt; header;\nstd::vector&lt;uint8_t&gt; body;\n};\n</code></pre> This is the basic structure of a message. The <code>MessageHeader</code> contains the custom data type that we created earlier. Thanks to the <code>id{}</code> syntaxe, it can be any type of data, even struct or class (in those cases the constructor will be called by default).</p>"},{"location":"Network/network/#create-a-message","title":"Create a message","text":"<pre><code>    net::message&lt;CustomMsgTypes&gt; msg;\nmsg.header.id = CustomMsgTypes::PlayerData;\n</code></pre>"},{"location":"Network/network/#fill-a-message","title":"Fill a message","text":"<pre><code>    int a = 5;\nfloat b = 3.14f;\nstruct\n{\nint a;\nint b;\n} data[5];\n\nmsg &lt;&lt; a &lt;&lt; b &lt;&lt; data;\n</code></pre>"},{"location":"Network/network/#extract-data-from-a-message","title":"Extract data from a message","text":"<p><pre><code>    int a;\nfloat b;\nstruct\n{\nint a;\nint b;\nfloat c;\n} data[5];\n\nmsg &gt;&gt; data &gt;&gt; b &gt;&gt; a;\n</code></pre> As you can see we <code>filled</code> the message in the order [a -&gt; b -&gt; data]</p> <p>And then we <code>extracted</code> the data in the order [data -&gt; b -&gt; a]</p> <p>This is because the message structure works like a pile. So the last item we put in the message will be the first one we extract.</p>"},{"location":"Network/network/#client","title":"Client","text":"<p><pre><code>client_interface() = default;\n</code></pre> This method will <code>create</code> a client</p>"},{"location":"Network/network/#clientconnect","title":"Client::connect()","text":"<pre><code>bool connect(const std::string&amp; host, const size_t port)\n</code></pre> <p>This method will <code>connect</code> the client to the given host and port\\ Returns true if the connection is successful, false otherwise</p>"},{"location":"Network/network/#server","title":"Server","text":"<p><pre><code>Server::Server(uint16_t port);\n</code></pre> this method will <code>create</code> a server on the given port</p>"},{"location":"Network/network/#serverstart","title":"Server::start()","text":"<p><pre><code>bool Server::start();\n</code></pre> this method will <code>start</code> the server</p> <p>if an error occurs it will throw an exception and print the error message on the error output</p> <p>then it will return false</p> <p>otherwise it will return true and the server will be running</p>"},{"location":"Network/network/#serverstop","title":"Server::stop()","text":"<p><pre><code>void Server::stop();\n</code></pre> this method will <code>stop</code> the server</p>"},{"location":"Network/network/#servermessageclient","title":"Server::messageClient()","text":"<pre><code>void messageClient(std::shared_ptr&lt;connection&lt;T&gt;&gt; client,\nconst Message&lt;T&gt;&amp; msg)\n</code></pre> <p>This method will <code>sends a message</code> to a connected client. If the client has disconnected, it removes the client from the list of connections.</p>"},{"location":"Network/network/#servermessageallclients","title":"Server::messageAllClients()","text":"<pre><code>void messageAll(const Message&lt;T&gt;&amp; msg)\n</code></pre> <p>This method will <code>sends a message</code> to all connected clients.</p>"},{"location":"Network/network/#serverupdate","title":"Server::update()","text":"<pre><code>void update(size_t maxMessages = -1)\n</code></pre> <p>This method will <code>update</code> the server by processing incoming messages It take one argument maxMessages. Default value is -1, which means all available messages will be processed.</p>"},{"location":"Network/network/#serveronmessage","title":"Server::onMessage()","text":"<pre><code>virtual void onMessage(std::shared_ptr&lt;connection&lt;T&gt;&gt;&amp; client, Message&lt;T&gt;&amp; msg)\n</code></pre> <p>This method is called when a <code>message is received</code>.\\ It is a virtual method, so you can override it to implement your own behavior.</p>"},{"location":"Network/network/#udp-server","title":"Udp Server","text":"<pre><code>class customServer : public net::server&lt;tcpProtocol&gt;\n</code></pre> <p>Custom server class that inherits from the server class and uses the UDP protocol.\\ You can find the same methods as the server class.\\ The only difference is that the custom server class uses the <code>UDP</code> protocol.</p>"},{"location":"Network/network/#customserverstartlobby","title":"customServer::startLobby","text":"<pre><code>void startLobby();\n</code></pre> <p>This method will <code>start</code> the lobby. It will create a udp socket and send it to clients so they can start to communicate on it. Then, the server will add the Clients to his list upon reception of the first message</p>"},{"location":"Network/network/#contributing","title":"Contributing","text":"<p>If you want to contribute to this part of the project, you can do several things:     - Add new DataTypes     - Implement differents custom clients and servers     - Add new protocols     - Add new features</p> <p>Then you can make a pull request and we will review it.</p> <p>Keep in mind the code style and the naming convention. Here is a little reminder:     - The variables and methods names are in camelBack     - The classes names are in CamelCase     - The macros names are in CAPITAL_LETTERS     - The namespaces names are in snake_case     - The brackets have to be on the same line for statements and on the next line for functions     - The indentation is 4 spaces</p>"},{"location":"Network/network/#protocol-documentation","title":"Protocol documentation","text":"<p>{{RFC|1234|auteur=Th\u00e9o Liennard|titre=A simple custom protocol for the FLib|date=2023-10-23|}}</p> <p>Here, we will be talking about the protocol used in the custom client and server. The protocol is based on the TCP and UDP protocol.</p>"},{"location":"Network/network/#tcp-protocol","title":"TCP Protocol","text":"<p>The TCP protocol is used to connect the client to the server and to validate the client. It is also used to send important informations because it is more reliable than the UDP protocol.</p> <p><pre><code>enum class tcpProtocol : uint8_t\n{\nUdp,\nStartRoom\n};\n</code></pre> As you can see, the tcp protocol is really simple. It only contains two commands:     - Udp: this command is used to tell the client that the server is starting a udp protocol and that the client has to connect to the udp socket.         The port and the ip of the udp socket are sent in the message.     - StartRoom: this command is used to tell the server that the client want to start a server, this can be used to let clients create their own room.</p>"},{"location":"Network/network/#packages","title":"Packages","text":"<p><pre><code>    struct Message {\nMessageHeader&lt;T&gt; header;\nstd::vector&lt;uint8_t&gt; body;\n}\n</code></pre> The header of the message contains the type of the message and the size of the body. The body contains the data that we want to send. It is sent using a vector of uint8_t.</p>"},{"location":"Network/network/#udp-protocol","title":"UDP Protocol","text":"<p>So, now that game is started and the client is connected to the udp socket, we can use the udp protocol to send and receive datas faster than with the tcp protocol.</p> <p><pre><code>enum class udpProtocol : uint8_t\n{\nConnectedPlayer,\nCreatePlayer,\nCreateEnnemy,\nCreateBullet,\nDestroy,\nPlayerMove,\nResync,\n};\n</code></pre> As you can see, the udp protocol is more complex than the tcp protocol. This is because we need to send more informations.</p> <p>In this example, the server owns every game objects. So the client has to ask the server to create a game object. And the server has to send the informations of the game objects to the client. It is also necessary to send the informations of the players to the other players.</p> <p>By using this server side architecture, we can avoid cheating. And we can also avoid the problem of synchronisation between the clients. The server has the official version of the game, and the clients are just displaying it.</p> <p>So now that we know why we need to send all those informations, let's see how we do it.</p> <p>Let's take the example of the player. At the beginning of the game, the server send to each player, a <code>CreatePlayer</code> message. This message contains the informations of the player. Then, each time the player moves, the client send a <code>PlayerMove</code> message to the server. The server will then send a <code>PlayerMove</code> message to all the other players.</p> <p>And so on for the other game objects.</p> <p>The resync command is used to resync the client with the server. It is used x times per second to make sure that the client is up to date.</p>"},{"location":"Network/network/#packages_1","title":"Packages","text":"<pre><code>    #define MSG_SIZE 1024\n\nstruct MessageUdp {\nMessageHeaderUdp&lt;T&gt; header;\nstd::array&lt;uint8_t, MSG_SIZE - sizeof(header)&gt; body = {};\n}\n</code></pre> <p>The header of the message contains the type of the message. The body contains the data that we want to send. Here we use an array of uint8_t because the size of the body is fixed. Each package has a size of 1024 bytes. It is necessary to use a fixed size because the udp protocol does not guarantee the order of the packages.</p>"},{"location":"Network/network/#authorscontacts","title":"Authors/Contacts","text":"<p>Principals contributors:     - [TotoFunki] : https://github.com/TotoFunki     - [ClementMNT] : https://github.com/ClementMNT</p>"},{"location":"Network/network/#useful-links","title":"Useful Links","text":"<p>Asio documentation: https://think-async.com/Asio/.</p>"},{"location":"Network/network/#conclusion","title":"Conclusion","text":"<p>R\u00e9sumez les points cl\u00e9s de la documentation de cet aspect et r\u00e9it\u00e9rez son importance dans le cadre du projet. Mentionnez d'\u00e9ventuels d\u00e9veloppements ou am\u00e9liorations futurs.</p> <p>H\u00e9sitez pas \u00e0 regarder comment faire dans les fichiers markdown si vous voulait faire des truc un peux sytl\u00e9 pour savoir les package qu'on a il sont:     - pymdownx     - material-mkdocs</p>"},{"location":"Server/server/","title":"[Aspect du Projet]","text":""},{"location":"Server/server/#introduction","title":"Introduction","text":"<p>Cette section doit fournir une br\u00e8ve introduction \u00e0 l'aspect sp\u00e9cifique du projet, tel que le Game Engine ou la fonctionnalit\u00e9 R\u00e9seau. Expliquez son importance et comment il s'int\u00e8gre dans l'ensemble du projet.</p>"},{"location":"Server/server/#objectif","title":"Objectif","text":"<p>D\u00e9crivez le principal objectif ou la principale finalit\u00e9 de cet aspect du projet. Quel probl\u00e8me r\u00e9sout-il et pourquoi est-il essentiel pour la r\u00e9ussite du projet ?</p>"},{"location":"Server/server/#vue-architecturale","title":"Vue Architecturale","text":"<p>Fournissez un aper\u00e7u architectural de haut niveau de cet aspect du projet. Utilisez des diagrammes, des graphiques ou des supports visuels pour illustrer les principaux composants et leur interaction.</p>"},{"location":"Server/server/#principaux-systemes","title":"Principaux Syst\u00e8mes","text":"<p>Expliquez les principaux syst\u00e8mes ou sous-syst\u00e8mes au sein de cet aspect du projet et comment ils contribuent \u00e0 sa fonctionnalit\u00e9.</p>"},{"location":"Server/server/#premiers-pas","title":"Premiers Pas","text":"<p>Incluez des instructions pour la configuration et la mise en place de cet aspect du projet. Liste des d\u00e9pendances, des exigences ou des plates-formes prises en charge sp\u00e9cifiques \u00e0 cet aspect. Offrez des conseils sur la construction et l'utilisation de ce composant. Fournissez des \u00e9tapes d'installation ou de configuration n\u00e9cessaires.</p>"},{"location":"Server/server/#tutoriels-et-guides","title":"Tutoriels et Guides","text":"<p>Incluez des tutoriels et des guides pratiques pour travailler avec cet aspect du projet. Il peut s'agir d'instructions \u00e9tape par \u00e9tape, d'exemples de code ou de sc\u00e9narios d'utilisation.</p>"},{"location":"Server/server/#directives-de-contribution","title":"Directives de Contribution","text":"<p>D\u00e9finissez les directives pour contribuer \u00e0 cet aspect sp\u00e9cifique du projet. Incluez des informations sur les conventions de codage, les processus et les attentes pour les d\u00e9veloppeurs qui souhaitent travailler sur cette partie du projet.</p>"},{"location":"Server/server/#documentation-du-protocole-le-cas-echeant","title":"Documentation du Protocole (le cas \u00e9ch\u00e9ant)","text":"<p>Si cet aspect du projet implique un protocole de communication (par exemple, pour la communication r\u00e9seau), fournissez une documentation d\u00e9taill\u00e9e sur le protocole. Cela devrait inclure :</p> <ul> <li>Une description des commandes et des paquets utilis\u00e9s dans la communication.</li> <li>Toute documentation formelle, telle qu'une RFC (Request for Comments), le cas \u00e9ch\u00e9ant.</li> <li>Des exemples de comment utiliser le protocole pour interagir avec le composant.</li> </ul>"},{"location":"Server/server/#auteurscontacts","title":"Auteurs/Contacts","text":"<p>Listez les auteurs ou les membres de l'\u00e9quipe responsables du d\u00e9veloppement et de la maintenance de cet aspect du projet. Incluez des informations de contact ou des liens vers leurs profils si n\u00e9cessaire.</p>"},{"location":"Server/server/#liens-utiles","title":"Liens Utiles","text":"<p>Fournissez des liens vers des ressources pertinentes, telles que des documents connexes, des biblioth\u00e8ques ou des r\u00e9f\u00e9rences externes qui peuvent aider les d\u00e9veloppeurs \u00e0 comprendre et \u00e0 travailler avec cet aspect du projet.</p>"},{"location":"Server/server/#conclusion","title":"Conclusion","text":"<p>R\u00e9sumez les points cl\u00e9s de la documentation de cet aspect et r\u00e9it\u00e9rez son importance dans le cadre du projet. Mentionnez d'\u00e9ventuels d\u00e9veloppements ou am\u00e9liorations futurs.</p> <p>H\u00e9sitez pas \u00e0 regarder comment faire dans les fichiers markdown si vous voulait faire des truc un peux sytl\u00e9 pour savoir les package qu'on a il sont:     - pymdownx     - material-mkdocs</p>"}]}