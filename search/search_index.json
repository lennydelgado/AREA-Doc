{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Installation","text":"<p>To begin with, in order to use the project, you need to clone it using the following command:</p> <pre><code>git clone git@github.com:EpitechPromo2026/B-CPP-500-MAR-5-1-rtype-theo.liennard.git\n</code></pre> <p>Once you have obtained the project, navigate to it to install the dependencies.</p>"},{"location":"#dependency-installation","title":"Dependency Installation","text":"<p>The installation of dependencies varies significantly depending on the operating system used.</p> <p>Before proceeding, you need to install conan, which is an open-source tool that facilitates the installation of external C/C++ libraries.</p> <p>To install it, visit https://conan.io/downloads</p> <p>Install conan according to your operating system or the method you prefer to use.</p> <p>To verify its installation, you can now execute the following command, which allows conan to detect the version of the compiler you are using and several other necessary pieces of information for its operation.</p> <p>Note</p> <p>This command must be executed in the project directory, not elsewhere.</p> <pre><code>conan profile detect --force\n</code></pre> <p>Once this is done, you need to prepare the files to install the dependencies.</p> <pre><code>conan install . --output-folder=build --build=missing\n</code></pre> <p>Warning</p> <p>You may encounter an error during the execution of this command. If this is the case, you must execute the following command:</p> <pre><code>    conan config home\n</code></pre> <p>then add the following lines to the global.conf file in folder that was returned by the previous command:</p> <pre><code>    tools.system.package_manager:mode=install\n    tools.system.package_manager:sudo=True\n</code></pre> For Linux and MacOSFor Windows <p>To complete the installation of dependencies, execute the following commands. First, navigate to the build directory.</p> <pre><code>cd build\n</code></pre> <p>Then, proceed to install the dependencies.</p> <pre><code>cmake .. -DCMAKE_TOOLCHAIN_FILE=conan_toolchain.cmake -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>Now, you can initiate the project compilation with the following command:</p> <p>Note</p> <p>To execute this command, you must be in the build directory.</p> <pre><code>cmake --build .\n</code></pre> <p>To complete the installation of dependencies, execute the following commands. First, navigate to the build directory.</p> <pre><code>cd build\n</code></pre> <p>Then, proceed to install the dependencies.</p> <pre><code># assuming Visual Studio 15 2017 is your VS version and that it matches your default profile\ncmake .. -G \"Visual Studio 15 2017\" -DCMAKE_TOOLCHAIN_FILE=./conan_toolchain.cmake\n</code></pre> <p>Now, you can initiate the project compilation with the following command:</p> <p>Note</p> <p>To execute this command, you must be in the build directory.</p> <pre><code>cmake --build . --config Release\n</code></pre>"},{"location":"GameDesign/gameDesign/","title":"Getting started","text":""},{"location":"GameDesign/gameDesign/#wip","title":"WIP","text":"<p>IN WIP</p>"},{"location":"GameEngine/gameEngine/","title":"Getting started","text":""},{"location":"GameEngine/gameEngine/#game-engine","title":"Game Engine","text":""},{"location":"GameEngine/gameEngine/#introduction","title":"Introduction","text":"<p>The Game Engine is the main part of the project, it is the part that manages the game loop, the entities, the systems, the events, the rendering and the network.</p>"},{"location":"GameEngine/gameEngine/#goal","title":"Goal","text":"<p>The goal of the game engine is to provide a simple and efficient way to create a game with the ECS architecture it provides and to be able to use it in a networked environment.</p>"},{"location":"GameEngine/gameEngine/#architectural-view","title":"Architectural View","text":"<pre><code>stateDiagram-v2\n    state Game {\n        direction LR\n        state GameLogic {\n            direction LR\n            player\n            ennemy\n            ...\n        }\n        state GameEngine {\n            state ECS {\n                state Entity {\n                    direction LR\n                    [Components...]\n                }\n                Entity --&gt; System\n            }\n            state Network {\n                direction LR\n                ...\n            }\n            state Event {\n                direction LR\n                KeyboardEvent\n                MouseEvent\n                WindowEvent\n            }\n            state Render {\n                direction LR\n                state SFML {\n                    direction LR\n                    2D\n                }\n            }\n        }\n    }</code></pre>"},{"location":"GameEngine/gameEngine/#first-steps","title":"First steps","text":"<p>To use the game engine you need to have the following dependencies: - Conan - Package Manager - CMake - Compiler</p> <p>To build the project you need to use the following commands: <pre><code>conan profile detect --force\nconan install . --output-folder=build --build=missing\ncd build\ncmake .. -DCMAKE_TOOLCHAIN_FILE=conan_toolchain.cmake -DCMAKE_BUILD_TYPE=Release\ncmake --build .\n</code></pre></p> <p>Follow the installation instructions on the Installation page and you should have the game engine compiled as a library in the <code>build/GameEngine</code> folder.</p>"},{"location":"GameEngine/gameEngine/#tutorial","title":"Tutorial","text":"<p>In this section we will explain how to use the game engine to create a simple game.</p>"},{"location":"GameEngine/gameEngine/#include-required-files","title":"Include required files","text":"<p>To use the game engine you need to include the following files: <pre><code>#include \"gameEngine.hpp\"\n</code></pre></p>"},{"location":"GameEngine/gameEngine/#create-your-own-components","title":"Create your own components","text":"<p>The game engine is based on the ECS architecture, so you need to create your own components to use it or use the ones already created. For the sake of the example we will create our own components.</p> <p>To create a component you just need to create a struct with the properties you want to have in your component. <pre><code>struct Position {\nfloat x;\nfloat y;\n};\n\nstruct Velocity {\nfloat x;\nfloat y;\n};\n\nstruct Sprite {\ngameEngine::Sprite sprite;\n\nSprite() {\nsprite.setTexture(gameEngine::Texture());\n}\n\nsetPosition(float x, float y) {\nsprite.setPosition(x, y);\n}\n};\n</code></pre></p>"},{"location":"GameEngine/gameEngine/#create-your-own-systems","title":"Create your own systems","text":"<p>The game engine is based on the ECS architecture, so you need to create your own systems to use it or use the ones already created. For the sake of the example we will create our own systems.</p> <p>To create a system you just need to create a function that takes a <code>GameEngine &amp;</code> as a parameter, a list of components you want to use, some extra parameters if you need them and return void. <pre><code>void move(GameEngine &amp;engine, SparseArray&lt;Position&gt; &amp;positions, SparseArray&lt;Velocity&gt; &amp;velocities) {\nfor (auto &amp;pos : positions) {\nif (velocities.has(pos.first)) {\npos.second.x += velocities[pos.first].x;\npos.second.y += velocities[pos.first].y;\n}\n}\n}\n\nvoid render(GameEngine &amp;engine, SparseArray&lt;Position&gt; &amp;positions, SparseArray&lt;Sprite&gt; &amp;sprites, gameEngine::RenderWindow &amp;window) {\nfor (auto &amp;pos : positions) {\nif (sprites.has(pos.first)) {\nsprites[pos.first].setPosition(pos.second.x, pos.second.y);\nwindow.draw(sprites[pos.first].sprite);\n}\n}\n}\n</code></pre></p>"},{"location":"GameEngine/gameEngine/#create-your-own-game","title":"Create your own game","text":"<p>To create your own game you first need to register your components and systems to the game engine. <pre><code>GameEngine engine;\ngameEngine::RenderWindow window(gameEngine::VideoMode(1280, 720), \"GameEngine window\");\n\nengine.registerComponent&lt;Position&gt;();\nengine.registerComponent&lt;Velocity&gt;();\n\nengine.addSystem&lt;Position, Velocity&gt;(move);\nengine.addSystem&lt;Position, Sprite&gt;(render, window);\n</code></pre></p> <p>Then you need to create your entities and add them to the game engine. <pre><code>Entity entity = engine.spawnEntity();\n\nPosition pos{0, 0};\nengine.addComponent(entity, pos);\n\nVelocity vel{1, 1};\nengine.addComponent(entity, vel);\n</code></pre></p> <p>Now that we have setup our entity we can start the game loop. <pre><code>while (window.isOpen()) {\ngameEngine::Event event;\nwhile (window.pollEvent(event)) {\nif (event.type == gameEngine::Event::Closed) {\nwindow.close();\n}\n}\n\nwindow.clear();\n\nengine.runSystems();\n\nwindow.display();\n}\n</code></pre></p> <p>But maybe you want to execute some code based on a tick rate, you can do that by using the <code>setInterval</code> method. <pre><code>engine.setInterval([]() {\nstd::cout &lt;&lt; \"Hello World every 1s\" &lt;&lt; std::endl;\n}, 1000); // 1000ms = 1s\n</code></pre></p> <p>Or maybe you want to execute some code only once but after a certain amount of time, you can do that by using the <code>setTimeout</code> method. <pre><code>engine.setTimeout([]() {\nstd::cout &lt;&lt; \"Hello World after 10s\" &lt;&lt; std::endl;\n}, 10000); // 10000ms = 10s\n</code></pre></p>"},{"location":"GameEngine/gameEngine/#full-example","title":"Full example","text":"<pre><code>#include \"gameEngine.hpp\"\n\nstruct Position {\nfloat x;\nfloat y;\n};\n\nstruct Velocity {\nfloat x;\nfloat y;\n};\n\nstruct Sprite {\ngameEngine::Sprite sprite;\n\nSprite() {\nsprite.setTexture(gameEngine::Texture());\n}\n\nsetPosition(float x, float y) {\nsprite.setPosition(x, y);\n}\n};\n\nvoid move(GameEngine &amp;engine, SparseArray&lt;Position&gt; &amp;positions, SparseArray&lt;Velocity&gt; &amp;velocities) {\nfor (auto &amp;pos : positions) {\nif (velocities.has(pos.first)) {\npos.second.x += velocities[pos.first].x;\npos.second.y += velocities[pos.first].y;\n}\n}\n}\n\nvoid render(GameEngine &amp;engine, SparseArray&lt;Position&gt; &amp;positions, SparseArray&lt;Sprite&gt; &amp;sprites, gameEngine::RenderWindow &amp;window) {\nfor (auto &amp;pos : positions) {\nif (sprites.has(pos.first)) {\nsprites[pos.first].setPosition(pos.second.x, pos.second.y);\nwindow.draw(sprites[pos.first].sprite);\n}\n}\n}\n\nint main() {\nGameEngine engine;\ngameEngine::RenderWindow window(gameEngine::VideoMode(1280, 720), \"GameEngine window\");\n\nengine.registerComponent&lt;Position&gt;();\nengine.registerComponent&lt;Velocity&gt;();\n\nengine.addSystem&lt;Position, Velocity&gt;(move);\nengine.addSystem&lt;Position, Sprite&gt;(render, window);\n\nEntity entity = engine.spawnEntity();\n\nPosition pos{0, 0};\nengine.addComponent(entity, pos);\n\nVelocity vel{1, 1};\nengine.addComponent(entity, vel);\n\nengine.setInterval([]() {\nstd::cout &lt;&lt; \"Hello World every 1s\" &lt;&lt; std::endl;\n}, 1000); // 1000ms = 1s\nengine.startTick();\n\nwhile (window.isOpen()) {\ngameEngine::Event event;\nwhile (window.pollEvent(event)) {\nif (event.type == gameEngine::Event::Closed) {\nwindow.close();\n}\n\nif (event.type == gameEngine::Event::KeyPressed) {\nif (event.key.code == gameEngine::Keyboard::Escape) {\nengine.setTimeout([]() {\nstd::cout &lt;&lt; \"Hello World after 10s\" &lt;&lt; std::endl;\n}, 10000); // 10000ms = 10s\n}\n}\n}\n\nwindow.clear();\n\nengine.runSystems();\n\nwindow.display();\n}\n\nreturn 0;\n}\n</code></pre>"},{"location":"GameEngine/gameEngine/#authorscontacts","title":"Authors/Contacts","text":"<ul> <li>Kenan Blasius</li> </ul>"},{"location":"GameEngine/gameEngine/#conclusion","title":"Conclusion","text":"<p>The game engine is the main part of the project, it is the part that manages the entities, the systems, the events and the rendering.</p>"},{"location":"Network/network/","title":"Networking Library","text":""},{"location":"Network/network/#introduction","title":"Introduction","text":"<p>The networking is a really important part of the project. It is used to communicate between the server and the client.</p>"},{"location":"Network/network/#objectif","title":"Objectif","text":"<p>The stake of this part is to be able to send and receive any kind of data. It has to be fast and reliable.</p>"},{"location":"Network/network/#architectural-view","title":"Architectural View","text":"<pre><code>stateDiagram-v2\n    direction LR\n    state Network {\n        [*] --&gt; Server\n        [*] --&gt; Client\n        Server --&gt; tcpConnection\n        Server --&gt; udpConnection\n        Client --&gt; tcpConnection\n        Client --&gt; udpConnection\n        state Server {\n            direction LR\n            MultiplesTcpConnections\n            MultiplesUdpConnections\n            state update {\n                [*] --&gt; tcp\n                [*] --&gt; udp\n            }\n        }\n        state Client {\n            direction LR\n            UniqueTcpConnection\n            UniqueUdpConnection\n            state _update {\n                [*] --&gt; _tcp\n                [*] --&gt; _udp\n            }\n        }\n        tcpConnection --&gt; tsQueueMessages\n        udpConnection --&gt; tsQueueMessages\n    }</code></pre>"},{"location":"Network/network/#main-systems","title":"Main systems","text":"<p>The main system of the FLib is the Tcp protocol. However, the lib is providing a custom client wich uses tcp protocol to connect to clients and to validate them. Then when the game starts, it uses an udp custom protocol that sends and receive datas faster. Those two protocol works together, each one has his own strenght, and his weaknesses. Use the tcp to send important informations because the udp is less reliable and could lose the packet.</p>"},{"location":"Network/network/#usage","title":"Usage","text":"<p>the network interface is based on the asio library. it is working on all platforms and is fully customisable. To use the FLib, you have to create custom DataTypes. Those DataTypes will be used to identify the type of data that you want to send.</p> <p>You can add or modify those DataTypes in the file <code>protocol.hpp</code>.</p> <p>Here is an example:</p> <p><pre><code>    enum class CustomMsgTypes : uint32_t\n{\nPlayerData,\nFireBullet,\nMovePlayer,\nPlayerHealth\n};\n</code></pre> This is basicly an enum that you can use to implement different behaviors. Those DataTypes will be used in the Networking implementation. Go to Data Transfer for more details. Now all you have to do is to create a client and a server. Send datas using the <code>message</code> class and upon receive use the message class to extract the datas. For the server, you can use the methode <code>onMessage</code> to implement what you want to do when you receive a message.</p> <pre><code>    virtual void onMessage(std::shared_ptr&lt;connection&lt;T&gt;&gt;&amp; client, Message&lt;T&gt;&amp; msg)\n</code></pre>"},{"location":"Network/network/#here-is-a-simple-example-of-how-to-use-the-network-library","title":"Here is a simple example of how to use the network library.","text":""},{"location":"Network/network/#message-class","title":"message Class","text":"<p><pre><code>template &lt;typename T&gt;\nstruct MessageHeader\n{\nT id{}; // {} = default value / constructor for class\nsize_t size = 0;\n};\n\ntemplate &lt;typename T&gt;\nstruct message\n{\nMessageHeader&lt;T&gt; header;\nstd::vector&lt;uint8_t&gt; body;\n};\n</code></pre> This is the basic structure of a message. The <code>MessageHeader</code> contains the custom data type that we created earlier. Thanks to the <code>id{}</code> syntaxe, it can be any type of data, even struct or class (in those cases the constructor will be called by default).</p>"},{"location":"Network/network/#create-a-message","title":"Create a message","text":"<pre><code>    net::message&lt;CustomMsgTypes&gt; msg;\nmsg.header.id = CustomMsgTypes::PlayerData;\n</code></pre>"},{"location":"Network/network/#fill-a-message","title":"Fill a message","text":"<pre><code>    int a = 5;\nfloat b = 3.14f;\nstruct\n{\nint a;\nint b;\n} data[5];\n\nmsg &lt;&lt; a &lt;&lt; b &lt;&lt; data;\n</code></pre>"},{"location":"Network/network/#extract-data-from-a-message","title":"Extract data from a message","text":"<p><pre><code>    int a;\nfloat b;\nstruct\n{\nint a;\nint b;\nfloat c;\n} data[5];\n\nmsg &gt;&gt; data &gt;&gt; b &gt;&gt; a;\n</code></pre> As you can see we <code>filled</code> the message in the order [a -&gt; b -&gt; data]</p> <p>And then we <code>extracted</code> the data in the order [data -&gt; b -&gt; a]</p> <p>This is because the message structure works like a pile. So the last item we put in the message will be the first one we extract.</p>"},{"location":"Network/network/#client","title":"Client","text":"<p><pre><code>client_interface() = default;\n</code></pre> This method will <code>create</code> a client</p>"},{"location":"Network/network/#clientconnect","title":"Client::connect()","text":"<pre><code>bool connect(const std::string&amp; host, const size_t port)\n</code></pre> <p>This method will <code>connect</code> the client to the given host and port\\ Returns true if the connection is successful, false otherwise</p>"},{"location":"Network/network/#server","title":"Server","text":"<p><pre><code>Server::Server(uint16_t port);\n</code></pre> this method will <code>create</code> a server on the given port</p>"},{"location":"Network/network/#serverstart","title":"Server::start()","text":"<p><pre><code>bool Server::start();\n</code></pre> this method will <code>start</code> the server</p> <p>if an error occurs it will throw an exception and print the error message on the error output</p> <p>then it will return false</p> <p>otherwise it will return true and the server will be running</p>"},{"location":"Network/network/#serverstop","title":"Server::stop()","text":"<p><pre><code>void Server::stop();\n</code></pre> this method will <code>stop</code> the server</p>"},{"location":"Network/network/#servermessageclient","title":"Server::messageClient()","text":"<pre><code>void messageClient(std::shared_ptr&lt;connection&lt;T&gt;&gt; client,\nconst Message&lt;T&gt;&amp; msg)\n</code></pre> <p>This method will <code>sends a message</code> to a connected client. If the client has disconnected, it removes the client from the list of connections.</p>"},{"location":"Network/network/#servermessageallclients","title":"Server::messageAllClients()","text":"<pre><code>void messageAll(const Message&lt;T&gt;&amp; msg)\n</code></pre> <p>This method will <code>sends a message</code> to all connected clients.</p>"},{"location":"Network/network/#serverupdate","title":"Server::update()","text":"<pre><code>void update(size_t maxMessages = -1)\n</code></pre> <p>This method will <code>update</code> the server by processing incoming messages It take one argument maxMessages. Default value is -1, which means all available messages will be processed.</p>"},{"location":"Network/network/#serveronmessage","title":"Server::onMessage()","text":"<pre><code>virtual void onMessage(std::shared_ptr&lt;connection&lt;T&gt;&gt;&amp; client, Message&lt;T&gt;&amp; msg)\n</code></pre> <p>This method is called when a <code>message is received</code>.\\ It is a virtual method, so you can override it to implement your own behavior.</p>"},{"location":"Network/network/#udp-server","title":"Udp Server","text":"<pre><code>class customServer : public net::server&lt;tcpProtocol&gt;\n</code></pre> <p>Custom server class that inherits from the server class and uses the UDP protocol.\\ You can find the same methods as the server class.\\ The only difference is that the custom server class uses the <code>UDP</code> protocol.</p>"},{"location":"Network/network/#customserverstartlobby","title":"customServer::startLobby","text":"<pre><code>void startLobby();\n</code></pre> <p>This method will <code>start</code> the lobby. It will create a udp socket and send it to clients so they can start to communicate on it. Then, the server will add the Clients to his list upon reception of the first message</p>"},{"location":"Network/network/#contributing","title":"Contributing","text":"<p>If you want to contribute to this part of the project, you can do several things:     - Add new DataTypes     - Implement differents custom clients and servers     - Add new protocols     - Add new features</p> <p>Then you can make a pull request and we will review it.</p> <p>Keep in mind the code style and the naming convention. Here is a little reminder:     - The variables and methods names are in camelBack     - The classes names are in CamelCase     - The macros names are in CAPITAL_LETTERS     - The namespaces names are in snake_case     - The brackets have to be on the same line for statements and on the next line for functions     - The indentation is 4 spaces</p>"},{"location":"Network/network/#protocol-documentation","title":"Protocol documentation","text":"<p>{{RFC|1234|auteur=Th\u00e9o Liennard|titre=A simple custom protocol for the FLib|date=2023-10-23|}}</p> <p>Here, we will be talking about the protocol used in the custom client and server. The protocol is based on the TCP and UDP protocol.</p>"},{"location":"Network/network/#tcp-protocol","title":"TCP Protocol","text":"<p>The TCP protocol is used to connect the client to the server and to validate the client. It is also used to send important informations because it is more reliable than the UDP protocol.</p> <p><pre><code>enum class tcpProtocol : uint8_t\n{\nUdp,\nStartRoom\n};\n</code></pre> As you can see, the tcp protocol is really simple. It only contains two commands:     - Udp: this command is used to tell the client that the server is starting a udp protocol and that the client has to connect to the udp socket.         The port and the ip of the udp socket are sent in the message.     - StartRoom: this command is used to tell the server that the client want to start a server, this can be used to let clients create their own room.</p>"},{"location":"Network/network/#packages","title":"Packages","text":"<p><pre><code>    struct Message {\nMessageHeader&lt;T&gt; header;\nstd::vector&lt;uint8_t&gt; body;\n}\n</code></pre> The header of the message contains the type of the message and the size of the body. The body contains the data that we want to send. It is sent using a vector of uint8_t.</p>"},{"location":"Network/network/#udp-protocol","title":"UDP Protocol","text":"<p>So, now that game is started and the client is connected to the udp socket, we can use the udp protocol to send and receive datas faster than with the tcp protocol.</p> <p><pre><code>enum class udpProtocol : uint8_t\n{\nConnectedPlayer,\nCreatePlayer,\nCreateEnnemy,\nCreateBullet,\nDestroy,\nPlayerMove,\nResync,\n};\n</code></pre> As you can see, the udp protocol is more complex than the tcp protocol. This is because we need to send more informations.</p> <p>In this example, the server owns every game objects. So the client has to ask the server to create a game object. And the server has to send the informations of the game objects to the client. It is also necessary to send the informations of the players to the other players.</p> <p>By using this server side architecture, we can avoid cheating. And we can also avoid the problem of synchronisation between the clients. The server has the official version of the game, and the clients are just displaying it.</p> <p>So now that we know why we need to send all those informations, let's see how we do it.</p> <p>Let's take the example of the player. At the beginning of the game, the server send to each player, a <code>CreatePlayer</code> message. This message contains the informations of the player. Then, each time the player moves, the client send a <code>PlayerMove</code> message to the server. The server will then send a <code>PlayerMove</code> message to all the other players.</p> <p>And so on for the other game objects.</p> <p>The resync command is used to resync the client with the server. It is used x times per second to make sure that the client is up to date.</p>"},{"location":"Network/network/#packages_1","title":"Packages","text":"<pre><code>    #define MSG_SIZE 1024\n\nstruct MessageUdp {\nMessageHeaderUdp&lt;T&gt; header;\nstd::array&lt;uint8_t, MSG_SIZE - sizeof(header)&gt; body = {};\n}\n</code></pre> <p>The header of the message contains the type of the message. The body contains the data that we want to send. Here we use an array of uint8_t because the size of the body is fixed. Each package has a size of 1024 bytes. It is necessary to use a fixed size because the udp protocol does not guarantee the order of the packages.</p>"},{"location":"Network/network/#authorscontacts","title":"Authors/Contacts","text":"<p>Principals contributors:     - [TotoFunki] : https://github.com/TotoFunki     - [ClementMNT] : https://github.com/ClementMNT</p>"},{"location":"Network/network/#useful-links","title":"Useful Links","text":"<p>Asio documentation: https://think-async.com/Asio/.</p>"},{"location":"Network/network/#conclusion","title":"Conclusion","text":"<p>R\u00e9sumez les points cl\u00e9s de la documentation de cet aspect et r\u00e9it\u00e9rez son importance dans le cadre du projet. Mentionnez d'\u00e9ventuels d\u00e9veloppements ou am\u00e9liorations futurs.</p> <p>H\u00e9sitez pas \u00e0 regarder comment faire dans les fichiers markdown si vous voulait faire des truc un peux sytl\u00e9 pour savoir les package qu'on a il sont:     - pymdownx     - material-mkdocs</p>"},{"location":"Server/server/","title":"[Aspect du Projet]","text":""},{"location":"Server/server/#introduction","title":"Introduction","text":"<p>Cette section doit fournir une br\u00e8ve introduction \u00e0 l'aspect sp\u00e9cifique du projet, tel que le Game Engine ou la fonctionnalit\u00e9 R\u00e9seau. Expliquez son importance et comment il s'int\u00e8gre dans l'ensemble du projet.</p>"},{"location":"Server/server/#objectif","title":"Objectif","text":"<p>D\u00e9crivez le principal objectif ou la principale finalit\u00e9 de cet aspect du projet. Quel probl\u00e8me r\u00e9sout-il et pourquoi est-il essentiel pour la r\u00e9ussite du projet ?</p>"},{"location":"Server/server/#vue-architecturale","title":"Vue Architecturale","text":"<p>Fournissez un aper\u00e7u architectural de haut niveau de cet aspect du projet. Utilisez des diagrammes, des graphiques ou des supports visuels pour illustrer les principaux composants et leur interaction.</p>"},{"location":"Server/server/#principaux-systemes","title":"Principaux Syst\u00e8mes","text":"<p>Expliquez les principaux syst\u00e8mes ou sous-syst\u00e8mes au sein de cet aspect du projet et comment ils contribuent \u00e0 sa fonctionnalit\u00e9.</p>"},{"location":"Server/server/#premiers-pas","title":"Premiers Pas","text":"<p>Incluez des instructions pour la configuration et la mise en place de cet aspect du projet. Liste des d\u00e9pendances, des exigences ou des plates-formes prises en charge sp\u00e9cifiques \u00e0 cet aspect. Offrez des conseils sur la construction et l'utilisation de ce composant. Fournissez des \u00e9tapes d'installation ou de configuration n\u00e9cessaires.</p>"},{"location":"Server/server/#tutoriels-et-guides","title":"Tutoriels et Guides","text":"<p>Incluez des tutoriels et des guides pratiques pour travailler avec cet aspect du projet. Il peut s'agir d'instructions \u00e9tape par \u00e9tape, d'exemples de code ou de sc\u00e9narios d'utilisation.</p>"},{"location":"Server/server/#directives-de-contribution","title":"Directives de Contribution","text":"<p>D\u00e9finissez les directives pour contribuer \u00e0 cet aspect sp\u00e9cifique du projet. Incluez des informations sur les conventions de codage, les processus et les attentes pour les d\u00e9veloppeurs qui souhaitent travailler sur cette partie du projet.</p>"},{"location":"Server/server/#documentation-du-protocole-le-cas-echeant","title":"Documentation du Protocole (le cas \u00e9ch\u00e9ant)","text":"<p>Si cet aspect du projet implique un protocole de communication (par exemple, pour la communication r\u00e9seau), fournissez une documentation d\u00e9taill\u00e9e sur le protocole. Cela devrait inclure :</p> <ul> <li>Une description des commandes et des paquets utilis\u00e9s dans la communication.</li> <li>Toute documentation formelle, telle qu'une RFC (Request for Comments), le cas \u00e9ch\u00e9ant.</li> <li>Des exemples de comment utiliser le protocole pour interagir avec le composant.</li> </ul>"},{"location":"Server/server/#auteurscontacts","title":"Auteurs/Contacts","text":"<p>Listez les auteurs ou les membres de l'\u00e9quipe responsables du d\u00e9veloppement et de la maintenance de cet aspect du projet. Incluez des informations de contact ou des liens vers leurs profils si n\u00e9cessaire.</p>"},{"location":"Server/server/#liens-utiles","title":"Liens Utiles","text":"<p>Fournissez des liens vers des ressources pertinentes, telles que des documents connexes, des biblioth\u00e8ques ou des r\u00e9f\u00e9rences externes qui peuvent aider les d\u00e9veloppeurs \u00e0 comprendre et \u00e0 travailler avec cet aspect du projet.</p>"},{"location":"Server/server/#conclusion","title":"Conclusion","text":"<p>R\u00e9sumez les points cl\u00e9s de la documentation de cet aspect et r\u00e9it\u00e9rez son importance dans le cadre du projet. Mentionnez d'\u00e9ventuels d\u00e9veloppements ou am\u00e9liorations futurs.</p> <p>H\u00e9sitez pas \u00e0 regarder comment faire dans les fichiers markdown si vous voulait faire des truc un peux sytl\u00e9 pour savoir les package qu'on a il sont:     - pymdownx     - material-mkdocs</p>"}]}